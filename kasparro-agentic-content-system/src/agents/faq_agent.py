"""
FAQ Page Agent
Responsible for generating FAQ pages using content blocks and templates.
"""

from typing import Dict, Any, List
from .base_agent import BaseAgent, AgentContext
from ..models.product import Product
from ..models.content import GeneratedPage, ContentBlock
from ..models.questions import Question, QuestionSet
from ..blocks import (
    BenefitsBlock, UsageBlock, SafetyBlock, 
    IngredientsBlock, PricingBlock
)
from ..templates.faq_template import FAQTemplate


class FAQPageAgent(BaseAgent[Product, GeneratedPage]):
    """
    Agent responsible for generating FAQ pages.
    
    Responsibility: Orchestrate content blocks and template to produce
    a complete FAQ page.
    
    Input: Product model
    Output: GeneratedPage containing FAQ content
    """
    
    def __init__(self):
        super().__init__(
            agent_id="faq-page-agent",
            agent_name="FAQ Page Generator Agent"
        )
        self._dependencies = ["data-parser-agent", "question-generator-agent"]
        
        # Initialize content blocks
        self._blocks = {
            "benefits-block": BenefitsBlock(),
            "usage-block": UsageBlock(),
            "safety-block": SafetyBlock(),
            "ingredients-block": IngredientsBlock(),
            "pricing-block": PricingBlock()
        }
        
        # Initialize template
        self._template = FAQTemplate()
    
    def validate_input(self, input_data: Product) -> bool:
        """Validate product data."""
        return input_data is not None and bool(input_data.name)
    
    def execute(self, input_data: Product, context: AgentContext) -> GeneratedPage:
        """Generate FAQ page."""
        product = input_data
        
        # Step 1: Process all content blocks
        processed_blocks = self._process_blocks(product, context)
        
        # Step 2: Get questions from context (generated by QuestionGeneratorAgent)
        questions = context.get("questions", [])
        
        # If no questions in context, generate basic ones
        if not questions:
            questions = self._generate_basic_questions(product)
        
        # Select top questions for FAQ
        selected_questions = self._select_faq_questions(questions, min_count=5)
        
        # Step 3: Render page using template
        template_context = {
            "product": product,
            "product_name": product.name,
            "questions": selected_questions
        }
        
        faq_page = self._template.render(processed_blocks, template_context)
        
        # Store in context
        context.set("faq_page", faq_page)
        
        context.log(self.agent_id, "generated_faq_page", {
            "product_name": product.name,
            "questions_count": len(selected_questions),
            "blocks_used": list(processed_blocks.keys())
        })
        
        return faq_page
    
    def _process_blocks(self, product: Product, context: AgentContext) -> Dict[str, ContentBlock]:
        """Process all required content blocks."""
        processed = {}
        
        for block_id, block in self._blocks.items():
            try:
                content_block = block.process(product, {})
                processed[block_id] = content_block
                
                context.log(self.agent_id, "processed_block", {
                    "block_id": block_id,
                    "success": True
                })
                
            except Exception as e:
                context.log(self.agent_id, "block_error", {
                    "block_id": block_id,
                    "error": str(e)
                })
        
        return processed
    
    def _generate_basic_questions(self, product: Product) -> List[Question]:
        """Generate basic questions if none provided."""
        from ..models.questions import QuestionCategory
        
        questions = [
            Question(
                question_id="Q1",
                question_text=f"What is {product.name}?",
                category=QuestionCategory.INFORMATIONAL,
                priority=1
            ),
            Question(
                question_id="Q2",
                question_text=f"How do I use {product.name}?",
                category=QuestionCategory.USAGE,
                priority=1
            ),
            Question(
                question_id="Q3",
                question_text=f"What are the key ingredients in {product.name}?",
                category=QuestionCategory.INGREDIENTS,
                priority=2
            ),
            Question(
                question_id="Q4",
                question_text=f"Is {product.name} safe for sensitive skin?",
                category=QuestionCategory.SAFETY,
                priority=2
            ),
            Question(
                question_id="Q5",
                question_text=f"What is the price of {product.name}?",
                category=QuestionCategory.PURCHASE,
                priority=3
            )
        ]
        
        return questions
    
    def _select_faq_questions(self, questions: List[Question], min_count: int = 5) -> List[Question]:
        """Select questions for FAQ page, ensuring minimum count and diversity."""
        from ..models.questions import QuestionCategory
        
        selected = []
        categories_covered = set()
        
        # First pass: select highest priority from each category
        for category in QuestionCategory:
            category_questions = [q for q in questions if q.category == category]
            if category_questions:
                # Sort by priority and take top one
                category_questions.sort(key=lambda q: q.priority)
                selected.append(category_questions[0])
                categories_covered.add(category)
        
        # Second pass: add more questions if needed
        remaining_questions = [q for q in questions if q not in selected]
        remaining_questions.sort(key=lambda q: q.priority)
        
        while len(selected) < min_count and remaining_questions:
            selected.append(remaining_questions.pop(0))
        
        # Sort final selection by priority
        selected.sort(key=lambda q: q.priority)
        
        return selected
